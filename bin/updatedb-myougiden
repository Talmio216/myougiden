#!/usr/bin/env python3
import atexit
import errno
import gzip
import os
import signal
import sys
import tempfile
import time
import urllib.request
import xml.parsers.expat
import subprocess

import sqlite3 as sql
from glob import glob

try:
    from myougiden import *
except ImportError:
    sys.path.append('.')
    from myougiden import *

# JMdict expansions are too damn long
short_expansions = {
  'Buddh': 'Buddhism',
  'MA': 'martial arts',
  'Shinto': 'Shintō',
  'X': 'rude',
  'abbr': 'abbreviation',
  'adj-f': 'adnominal in adj. role',
  'adj-i': '-i verbal adj.',
  'adj-kari': "‘-kari’ verbal adj.",
  'adj-ku': "‘-ku’ verbal adj.",
  'adj-na': '‘na’ adjectival noun',
  'adj-nari': '‘nari’adjectival noun',
  'adj-no': "‘no’ adjectival noun'",
  'adj-pn': 'adnominal (pre-noun)',
  'adj-shiku': "‘-shiku’ verbal adj.",
  'adj-t': "‘-taru’ adj.",
  'adv': 'adverb',
  'adv-to': "‘-to’ adverb",
  'anat': 'anatomy',
  'arch': 'archaism',
  'archit': 'architecture',
  'astron': 'astronomy',
  'ateji': 'phonogram (ateji)',
  'aux': 'auxiliary',
  'aux-adj': 'auxiliary adj.',
  'aux-v': 'auxiliary verb',
  'baseb': 'baseball',
  'biol': 'biology',
  'bot': 'botany',
  'bus': 'business',
  'chem': 'chemistry',
  'chn': "child speech",
  'col': 'colloquial',
  'comp': 'computing',
  'conj': 'conj.',
  'ctr': 'counter',
  'derog': 'derogatory',
  'eK': 'exclusively kanji',
  'econ': 'economics',
  'ek': 'exclusively kana',
  'engr': 'engineering',
  'exp': 'expression',
  'fam': 'familiar',
  'fem': 'women’s speech',
  'finc': 'finance',
  'food': 'food',
  'geol': 'geology',
  'geom': 'geometry',
  'gikun': 'logogram (gikun/jukujikun)',
  'hob': 'Hokkaido-ben',
  'hon': 'honorific',
  'hum': 'humble',
  'iK': 'irregular kanji',
  'id': 'idiom',
  'ik': 'irregular kana',
  'int': 'interjection',
  'io': 'irregular okurigana',
  'iv': 'irregular verb',
  'joc': 'jocular',
  'ksb': 'Kansai-ben',
  'ktb': 'Kantō-ben',
  'kyb': 'Kyōto-ben',
  'kyu': 'Kyūshū-ben',
  'law': 'law',
  'ling': 'linguistics',
  'm-sl': 'manga slang',
  'male': 'men’s speech',
  'male-sl': 'male slang',
  'math': 'math',
  'med': 'medicine',
  'mil': 'military',
  'music': 'music',
  'n': 'noun',
  'n-adv': 'adverbial noun',
  'n-pr': 'proper noun',
  'n-pref': 'nominal prefix',
  'n-suf': 'nominal suffix',
  'n-t': 'temporal noun',
  'nab': 'Nagano-ben',
  'num': 'numeric',
  'oK': 'outdated kanji',
  'obs': 'obsolete',
  'obsc': 'obscure',
  'oik': 'old/irregular kana',
  'ok': 'obsolete kana',
  'on-mim': 'sound-symbolic',
  'osb': 'Osaka-ben',
  'physics': 'physics',
  'pn': 'pronoun',
  'poet': 'poetry',
  'pol': 'polite',
  'pref': 'prefix',
  'proverb': 'proverb',
  'prt': 'particle',
  'rare': 'rare',
  'rkb': 'Ryūkyū-ben',
  'sens': 'sensitive',
  'sl': 'slang',
  'sports': 'sports',
  'suf': 'suffix',
  'sumo': 'sumō',
  'thb': 'Tōhoku-ben',
  'tsb': 'Tosa-ben',
  'tsug': 'Tsugaru-ben',
  'uK': 'usually in kanji',
  'uk': 'usually in kana',
  'v-unspec': 'verb unspecified',
  'v1': 'ichidan verb',
  'v2a-s': "-u nidan verb",
  'v2b-k': "-bu upper nidan verb",
  'v2b-s': "-bu lower nidan verb",
  'v2d-k': "-dzu upper nidan verb",
  'v2d-s': "-dzu lower nidan verb",
  'v2g-k': "-gu upper nidan verb",
  'v2g-s': "-gu lower nidan verb",
  'v2h-k': "-hu/-fu upper nidan verb",
  'v2h-s': "-hu/-fu lower nidan verb",
  'v2k-k': "-ku upper nidan verb",
  'v2k-s': "-ku lower nidan verb",
  'v2m-k': "-mu upper nidan verb",
  'v2m-s': "-mu lower nidan verb",
  'v2n-s': "-nu lower nidan verb",
  'v2r-k': "-ru upper nidan verb",
  'v2r-s': "-ru lower nidan verb",
  'v2s-s': "-su lower nidan verb",
  'v2t-k': "-tsu upper nidan verb",
  'v2t-s': "-tsu lower nidan verb",
  'v2w-s': "-u lower nidan verb",
  'v2y-k': "-yu upper nidan verb",
  'v2y-s': "-yu lower nidan verb",
  'v2z-s': "-zu lower nidan verb",
  'v4b': "-bu yodan verb",
  'v4g': "-gu yodan verb",
  'v4h': "-hu/-fu yodan verb",
  'v4k': "-ku yodan verb",
  'v4m': "-mu yodan verb",
  'v4n': "-nu yodan verb",
  'v4r': "-ru yodan verb",
  'v4s': "-su yodan verb",
  'v4t': "-tsu yodan verb",
  'v5aru': 'aru godan verb',
  'v5b': "-bu godan verb",
  'v5g': "-gu godan verb",
  'v5k': "-ku godan verb",
  'v5k-s': 'iku/yuku godan verb',
  'v5m': "-mu godan verb",
  'v5n': "-nu godan verb",
  'v5r': "-ru godan verb",
  'v5r-i': "-ru irregular godan verb",
  'v5s': "-su godan verb",
  'v5t': "-tsu godan verb",
  'v5u': "-u godan verb",
  'v5u-s': "-u special godan verb",
  'v5uru': 'uru godan verb',
  'vi': 'intrans. verb',
  'vk': 'kuru verb',
  'vn': '-nu irregular verb',
  'vr': '-ru/-ri irregular verb',
  'vs': 'verbal (-suru) noun',
  'vs-c': '-su verb',
  'vs-i': 'verbal (-suru) noun, irregular',
  'vs-s': 'verbal (-suru) noun, special',
  'vt': 'trans. verb',
  'vulg': 'vulgar',
  'vz': '-zuru ichidan verb',
  'zool': 'zoology'
}

# updated directly from JMdict entities.
#
# used to un-expand entities.
long_expansions={}

# used for progress bar
donecount=0
todo=None

# rather than using transactions, locks and so on, it was found to be faster to
# just remove the file. so we create a new database, and move it over the old
# one on success.
PATHS['tmpdb'] = "%s.new.%d" % (PATHS['database'], os.getpid())
to_delete = []
# if problems are found, we just delete the temp database.
def cleanup():
    # sqlite creates "dbname-journal" files
    for path in glob(PATHS['tmpdb'] + '*'):
        os.remove(path)
    for f in to_delete:
        if os.path.isfile(f):
            os.remove(f)

atexit.register(cleanup)

def sigcleanup(signum, stack):
    print("Aborting on signal %d." % signum)
    cleanup()
    sys.exit(1)

for sn in (signal.SIGHUP, signal.SIGINT, signal.SIGQUIT, signal.SIGILL,
        signal.SIGABRT, signal.SIGFPE, signal.SIGSEGV, signal.SIGPIPE,
        signal.SIGTERM, signal.SIGBUS):
    signal.signal(sn, sigcleanup)

def nice_self():
    problem=False

    try:
        import psutil
        me = psutil.Process(os.getpid())
        me.set_nice(19)
        me.set_ionice(psutil.IOPRIO_CLASS_IDLE)

    except (ImportError, AttributeError):
        try:
            subprocess.call(['renice', '-n', '19',  str(os.getpid())])
        except OSError:
            problem=True

        try:
            subprocess.call(['ionice', '-c', 'idle', '-p', str(os.getpid())])
        except OSError:
            problem=True

    return problem == False

def create_tables(cur):
    # what about a custom collation function?

    # I couldn't make executemany() work as I expected. run one by one.
    cur.execute('DROP TABLE IF EXISTS versions;')
    cur.execute('DROP TABLE IF EXISTS abbreviations;')

    cur.execute('DROP TABLE IF EXISTS kanjis;')
    cur.execute('DROP TABLE IF EXISTS readings;')
    cur.execute('DROP TABLE IF EXISTS senses;')
    cur.execute('DROP TABLE IF EXISTS glosses;')
    cur.execute('DROP TABLE IF EXISTS entries;')

    cur.execute('''
      CREATE TABLE versions (
        dbversion TEXT PRIMARY KEY
      );
    ''')

    cur.execute('''
      INSERT INTO versions VALUES ( ? );
    ''', [DBVERSION])


    # basically what's encoded as entities in JMdict.xml .
    # notice the entity names are familiar from EDICT files.
    # abbrev = entity name
    # long_expansion = entity JMdict value
    # short_expansion = our own, shorter expansion
    cur.execute('''
      CREATE TABLE abbreviations (
        abbrev TEXT PRIMARY KEY,
        short_expansion TEXT DEFAULT NULL,
        long_expansion TEXT DEFAULT NULL
      );
    ''')

    # 'frequent' is roughly equivalent to the P flag in EDICT.
    # to simplify, at the moment we're adding it to the entire entry
    # (rather than indivually to reading/kanji pairs).
    cur.execute('''
      CREATE TABLE
      entries (
        ent_seq INTEGER PRIMARY KEY,
        frequent INTEGER DEFAULT 0
      );
    ''')

    cur.execute('''
      CREATE TABLE
      kanjis (
        ent_seq INTEGER NOT NULL,
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        kanji TEXT NOT NULL,
        FOREIGN KEY (ent_seq) REFERENCES entries(ent_seq)
      );
    ''')

    cur.execute('''
      CREATE TABLE
      readings (
        ent_seq INTEGER NOT NULL,
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        reading TEXT NOT NULL,
        FOREIGN KEY (ent_seq) REFERENCES entries(ent_seq)
      );
    ''')

    cur.execute('''
      CREATE TABLE
      senses (
        ent_seq INTEGER NOT NULL,
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        pos TEXT DEFAULT NULL,
        misc TEXT DEFAULT NULL,
        dial TEXT DEFAULT NULL,
        s_inf TEXT DEFAULT NULL,
        FOREIGN KEY (ent_seq) REFERENCES entries(ent_seq)
        FOREIGN KEY (pos) REFERENCES abbreviations(abbrev)
        FOREIGN KEY (misc) REFERENCES abbreviations(abbrev)
        FOREIGN KEY (dial) REFERENCES abbreviations(abbrev)
      );
    ''')

    cur.execute('''
      CREATE TABLE
      glosses (
        sense_id INTEGER NOT NULL,
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        gloss TEXT NOT NULL,
        FOREIGN KEY (sense_id) REFERENCES senses(id)
      );
    ''')

    cur.execute('''
      CREATE INDEX kanjis_ent_seq ON kanjis (ent_seq);
    ''')
    cur.execute('''
      CREATE INDEX readings_ent_seq ON readings (ent_seq);
    ''')
    cur.execute('''
      CREATE INDEX senses_ent_seq ON senses (ent_seq);
    ''')
    cur.execute('''
      CREATE INDEX glosses_sense_id ON glosses (sense_id);
    ''')

    cur.execute('''
      CREATE INDEX kanjis_kanji ON kanjis (kanji);
    ''')
    cur.execute('''
      CREATE INDEX readings_reading ON readings (reading);
    ''')
    cur.execute('''
      CREATE INDEX glosses_gloss ON glosses (gloss);
    ''')

def count_entries(jmdict):
    count=0

    def handle_end_el(el):
        nonlocal count
        if el == 'entry':
            count += 1

    p = xml.parsers.expat.ParserCreate()
    p.buffer_text = True
    p.EndElementHandler = handle_end_el
    p.ParseFile(jmdict)
    return count


# credits for ascii art: Dan Strychalski
coffee = []
coffee.append('''
 (  
  )
c[ ]
'''.strip("\n"))

coffee.append('''
   )
  ( 
c[ ]
'''.strip("\n"))
animation_frame = 0

def print_coffee():
    global donecount
    global todo
    global animation_frame

    sys.stdout.write(coffee[animation_frame])

    if donecount == todo:
        print(" %d/%d (100%%) All done!" %
              (donecount, todo))
    else:
        # 6: hardcoded len(str(todo))
        print(" %6d/%d (%2.2f%%) done..." %
              (donecount, todo, (float(donecount)/todo)*100))

    sys.stdout.flush()
    animation_frame = (animation_frame+1) % len(coffee)

def update_coffee(signum=None, frame=None):
    '''Handler for SIGALARM.'''

    # move up 3 lines
    sys.stdout.write('\033[3A')
    # move to start of line
    sys.stdout.write("\r")
    signal.alarm(1)

    print_coffee()

def make_database(jmdict, sqlite, progress=True):
    global todo
    global donecount

    mkdir_p(os.path.dirname(PATHS['database']))

    ent_seq = None
    sense_id = None
    cdata = None

    def handle_entity_decl(name,
            is_parameter_entity,
            value,
            base,
            system_id,
            public_id,
            notation_name):

        long_expansions[name] = value
        cur.execute('''
          INSERT INTO abbreviations(abbrev, short_expansion, long_expansion)
                 VALUES (?, ?, ?);
        ''', [name, short_expansions[name], value])

    def handle_start_el(el, attrs):
        nonlocal ent_seq
        nonlocal sense_id
        nonlocal cdata

        cdata = ''

        if el == 'sense':
            cur.execute('INSERT INTO senses(ent_seq) VALUES (?);', [ent_seq])
            cur.execute('SELECT max(id) FROM senses;')
            sense_id = cur.fetchone()[0]

    def handle_cdata(data):
        nonlocal cdata
        cdata += data

    def handle_end_el(el):
        nonlocal ent_seq
        nonlocal sense_id
        nonlocal cdata
        nonlocal progress
        global donecount

        if el == 'ent_seq':
            ent_seq = cdata
            cur.execute('INSERT INTO entries(ent_seq) VALUES (?);', [ent_seq])
            if progress:
                donecount += 1

        elif el == 'reb':
            cur.execute('INSERT INTO readings(ent_seq, reading) VALUES (?, ?);',
                    [ent_seq, cdata])

        elif el == 'keb':
            cur.execute('INSERT INTO kanjis(ent_seq, kanji) VALUES (?, ?);',
                    [ent_seq, cdata])

        elif el in ('ke_pri', 're_pri'):
            if cdata in ('news1', 'ichi1', 'spec1', 'gai1'):
                cur.execute('UPDATE entries SET frequent = 1 WHERE ent_seq = ?;', [ent_seq])

        elif el in ('pos', 'misc', 'dial'):
            for abr, exp in long_expansions.items():
                if cdata == exp:
                    abbrev = abr
                    break

            cur.execute('UPDATE senses SET %s = ? WHERE id = ?;' % el,
                    [abbrev, sense_id])

        elif el == 's_inf':
            cur.execute('UPDATE senses SET s_inf = ? WHERE id = ?;',
                        [cdata, sense_id])


        elif el == 'gloss':
            cur.execute('INSERT INTO glosses(sense_id, gloss) VALUES (?, ?);',
                    [sense_id, cdata])

    p = xml.parsers.expat.ParserCreate()
    p.buffer_text = True
    p.StartElementHandler = handle_start_el
    p.EndElementHandler = handle_end_el
    p.CharacterDataHandler = handle_cdata
    p.EntityDeclHandler = handle_entity_decl

    # it does nothing!
    # p.SetParamEntityParsing(xml.parsers.expat.XML_PARAM_ENTITY_PARSING_NEVER)

    con = sql.connect(PATHS['tmpdb'], isolation_level='IMMEDIATE')
    cur = con.cursor()

    create_tables(cur)

    if progress:
        sys.stdout.write("Counting entries...")
        todo = count_entries(jmdict)
        jmdict.seek(0)
        print(" %s to do." % todo)

        print_coffee()
        signal.signal(signal.SIGALRM, update_coffee)
        signal.alarm(1)

    p.ParseFile(jmdict)

    cur.close()
    con.commit()
    con.close()

def gzip_file(fpath):
    try:
        st = subprocess.call(['gzip', fpath])
        if st != 0:
            raise RuntimeError("gzip returned %d" % st)
    except OSError:
        bufsize = 1024*8
        plain = open(fpath, 'rb')
        gz = gzip.open(fpath + '.gz', 'wb')

        while 1:
            buf = plain.read(bufsize)
            if not buf:
                break
            gz.write(buf)

        plain.close()
        gz.close()
        os.remove(fpath)

def gunzip_file(fpathgz):
    try:
        st = subprocess.call(['gzip', '-d', fpathgz])
        if st != 0:
            raise RuntimeError("gzip -d returned %d" % st)
    except OSError:
        bufsize = 1024*8
        gz = gzip.open(fpathgz, 'rb')
        plain = open(re.sub(r'\.gz$', '', fpathgz), 'wb')

        while 1:
            buf = gz.read(bufsize)
            if not buf:
                break
            plain.write(buf)

        plain.close()
        gz.close()
        os.remove(fpathgz)

def fetch_jmdict_xml(localgz, update=True):
    localgz = os.path.realpath(localgz)

    if update and os.path.isfile(localgz):
        if re.search(r'\.gz$', localgz):
            localxml = re.sub(r'\.gz$', '', localgz)
        else:
            raise ValueError('not a .gz file: ' + localgz)

        try:
            print('Syncing file %s from %s' % (localgz, PATHS['jmdict_rsync_url']))
            gunzip_file(localgz)
            st = subprocess.call(['rsync', '--progress', '-v', '-z', PATHS['jmdict_rsync_url'], localxml])
            if st != 0:
                raise RuntimeError("rsync returned %d" % st)
            gzip_file(localxml)
        except Exception as e:
            if os.path.isfile(localxml):
                os.remove(localxml)

            print('Could not update JMdict file: %s' % str(e))
            print('Will try to download entire file from %s ...'
                  % PATHS['jmdictgz_http_url'])

            urllib.request.urlretrieve(PATHS['jmdictgz_http_url'], localgz)

    else:
        mkdir_p(os.path.dirname(localgz))

        print('Downloading dictionary data from %s to %s ...'
              % (PATHS['jmdictgz_http_url'], localgz))
        urllib.request.urlretrieve(PATHS['jmdictgz_http_url'], localgz)


if __name__ == '__main__':
    import argparse
    ap = argparse.ArgumentParser(formatter_class=argparse.RawTextHelpFormatter)

    ap.add_argument('-f', '--fetch', action='store_true',
                    help=('''Try to fetch JMdict_e.gz from
%s .''' % PATHS['jmdictgz_http_url']))

    ap.add_argument('-k', '--keep', action='store_true',
                    help='''Keep downloaded JMdict_e.gz file after fetching.  If
not set, it will be automatically deleted after use.''')

    ap.add_argument('-j', '--jmdict',
                    default=os.path.join(PATHS['vardir'], 'JMdict_e.gz'),
                    metavar='PATH',
                    help='''Path of local JMdict_e.gz file. Default:
%(default)s .''')

    ap.add_argument('--no-nice', action='store_false', dest='nice',
            help='''Don't lower process priority (default: try to be nice).''')

    args = ap.parse_args()

    if args.nice:
        nice_self()

    localxml_exists = os.path.isfile(args.jmdict)
    temp_xml = False

    if args.fetch and not args.keep and localxml_exists:
        # if they're keeping the file, they probably don't want to delete it.
        print("INFO: Local JMdict exists at %s ." % args.jmdict)
        print("      Will update and keep it.")
        args.keep = True

    if not localxml_exists and not args.fetch:
        # assume no one would want to call the script just to be told
        # "there's no file, please fetch"
        args.fetch = True

    if args.fetch and not args.keep:
        temp_xml = True

        # it seems that both gzip and urllib require visible filenames, and
        # can't just work with in-memory file objects.
        f, xmlgzpath = tempfile.mkstemp()
        to_delete.append(xmlgzpath)
    else:
        xmlgzpath = args.jmdict

    # check for already running process & leftovers
    updating_files = glob(PATHS['database'] + '.new.*')
    for uf in updating_files:
        m = re.match(PATHS['database'] + '.new.([0-9]*)', uf)
        pid = int(m.group(1))
        try:
            os.getpgid(pid)
            # weakness: if another process takes over same PID.
            print("updatedb-myougiden seems to be running at PID %d! Exiting..."
                  % pid)
            sys.exit(0)
        except OSError:
            print("Removing stale file %s" % uf)
            os.remove(uf)

    if args.fetch:
        fetch_jmdict_xml(xmlgzpath, update=(not temp_xml))

    if temp_xml:
        print("Compiling database from temporary file, please wait...")
    else:
        print("Compiling database from %s, please wait..." % xmlgzpath)

    progress = sys.stdout.isatty()
    make_database(gzip.open(xmlgzpath, 'r'), PATHS['tmpdb'], progress=progress)

    if temp_xml:
        print("Deleting temporary file.")
        os.remove(xmlgzpath)

    os.rename(PATHS['tmpdb'], PATHS['database'])
    atexit.unregister(cleanup)
    print("myougiden is ready to use, enjoy!")
